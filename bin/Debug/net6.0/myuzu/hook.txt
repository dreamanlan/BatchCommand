
@g_dir_chged : int = 0;
@g_last_time : int = 0;
@g_in_test : int = 0;
@g_enable_watch_point : int = 0;
@g_enable_mem_log : int = 0;

//======test code begin======
struct(TestStru3)
{
	count : int32;
	ptest2 : TestStru2[12];
};

@ga : int = 123;
@gb : int[3] = [3,5,1];
@gc : int = 456;
@gd : string = "this is a test";

hook(CompileTest)
{
	onenter{
		$a : int = 12;
		$b : int = 13 * 17;
		$d : int = ptrget(addr($a), 4);
		$e : int[4] = [1,$a,3,$b];
		$c : int;
		$e[1] = $d + $e[2] * $c;
		if ($a==12) {
			$c = $a * $b;
		};
		while($c!=0){
			$c = $c - 1;
		};
		loopi($c,0,3,1){
			$d = $d + 1;
		};
		loopd($c,8,0,-2){
			$d = $d + 1;
			break;
		};
		if($a == 12){
			$d = $d + 1;
		}
		else{
			$d = $d - 1;
		};
		$c = addr($e) + argv(0);
		$d = $c < 1 ? 2 : 3;
		$e[0] = $d ?? 1;
		$f : int = struct($d, ptr(ptr(TestStru3.ptest2).ptest).size);
		$g : int = dumpcascadeptr(addr($e), 0x08, 0x08);
		$h1 : int = offset(TestStru3.ptest2[3].size);
		$h2 : int = size(TestStru3);
		ffi(proto(void,noparams,[int,int],[],[]),0x1234,121,121);
		ffi(proto(void,noparams,[int],[float],[]),0x1235,123,123.00);
		return 0;
	};
};

hook(TestMacro1)
{
	onenter{
		$a:int = ptrget(argv(1),4);
		$b:int = ptrget(argv(2),8);
		$c:int = ptrget(argv(3),8);
		printf("TestMacro1 enter time:%lld a:%d b:%f c:%s\n",time(),$a,$b,$c);
		
		ptrset(argv(0),4,1);
		return 1;
	};
	onexit{
		printf("TestMacro1 exit time:%lld\n",time());
	};
};
hook(TestMacro2)
{
	onenter{
		$a:int = ptrget(argv(1),4);
		$b:int = ptrget(argv(2),8);
		$c:int = ptrget(argv(3),8);
		printf("TestMacro2 enter time:%lld a:%d b:%f c:%s\n",time(),$a,$b,$c);
		
		return 0;
	};
	onexit{
		printf("TestMacro2 exit time:%lld\n",time());
		ptrset(argv(0),4,2);
	};
};
hook(TestMacro3)
{
	onenter{
		$a:int = ptrget(argv(0),4);
		$b:int = ptrget(argv(1),8);
		$c:int = ptrget(argv(2),8);
		printf("TestMacro3 enter time:%lld a:%d b:%f c:%s\n",time(),$a,$b,$c);
		
		if(platform()==0){
			//test code on windows
			dumpcascadeptr(argv(2),0);
			if($a==123){
				ptrset(argv(0),4,1);
			}
			else{ 
				ptrset(argv(0),4,0);
			};
			$i:int = 0;
			loop($i,0,10){
				printf("+%d\n",$i);
			};
			$j:float = $i;
			while($j>0){
				printf("-%f\n",$j);
				//$j=$j-1;
				dec($j,2.0);
			};
			printf(">>> %f\n", $j);
			printf(">>> %f\n", inc($j));
			printf(">>> %f\n", inc($j, 2.0));
			printf(">>> %f\n", inc($j, 3.0));
			printf("%d %d %d\n", stkix(), hookid(), hookver());
			printf("str contains %d %d\n", stringcontains("test","es","te"), stringnotcontains("test","es","fg"));
			printf("str contains any %d %d\n", stringcontainsany("test","es","te"), stringnotcontainsany("test","es","fg"));
			printf("str find %d %d\n", stringfind("test","es"), stringrfind("test","es"));
			printf("str find2 %d %d\n", stringfind("test","es",1), stringrfind("test","es",0));
			$addr:int = 0x800010004003;
			printf("%llx\n", $addr & (~0x03));
		};

		return 1;
	};
	onexit{
		printf("TestMacro3 exit time:%lld\n",time());
	};
};
hook(TestMacro4)
{
	onenter{
		$a:int = ptrget(argv(0),4);
		$b:int = ptrget(argv(1),8);
		$c:int = ptrget(argv(2),8);
		printf("TestMacro4 enter time:%lld a:%d b:%f c:%s\n",time(),$a,$b,$c);
		
		return 0;
	};
	onexit{
		printf("TestMacro4 exit time:%lld\n",time());
	};
};

//======test code end======

hook(DbgScp_Set)
{
	onenter{
		$cmd:int = ptrget(argv(0),4);
		$a:int = ptrget(argv(1),4);
		$b:int = ptrget(argv(2),8);
		$c:int = ptrget(argv(3),8);
		printf("DbgScp_Set enter time:%lld cmd:%d a:%d b:%f c:%s\n",time(),$cmd,$a,$b,$c);
		
		return 1;
	};
	onexit{
		printf("DbgScp_Set exit time:%lld\n",time());
	};
};
hook(DbgScp_Get)
{
	onenter{
		$cmd:int = ptrget(argv(1),4);
		$a:int = ptrget(argv(2),4);
		$b:int = ptrget(argv(3),8);
		$c:int = ptrget(argv(4),8);
		printf("DbgScp_Get enter time:%lld cmd:%d a:%d b:%f c:%s\n",time(),$cmd,$a,$b,$c);
		
		return 0;
	};
	onexit{
		printf("DbgScp_Get exit time:%lld\n",time());
		ptrset(argv(0),4,2);
	};
};

hook("Vulkan::GraphicsPipeline::ctor")
{
	onenter{
		$this:int = ptrget(argv(0),8);
		$vshash:int = ptrget(argv(1),8);
		$geohash:int = ptrget(argv(2),8);
		$pshash:int = ptrget(argv(3),8);

		if ($vshash==0xfc6acaf325f8139a && $pshash==0xe7751a4a608bfc2d) {
			printf("Vulkan::GraphicsPipeline::ctor vs:%llx gs:%llx ps:%llx\n",$vshash,$geohash,$pshash);
		};
	};
};
hook("Vulkan::GraphicsPipeline::AfterMake")
{
	onenter{
		//$log:int = ptrget(argv(0),1);
		$this:int = ptrget(argv(1),8);
		$vshash:int = ptrget(argv(2),8);
		$geohash:int = ptrget(argv(3),8);
		$pshash:int = ptrget(argv(4),8);
		$desctmpl:int = ptrget(argv(5),8);

		//log
		ptrset(argv(0),1,1);
	};
};
hook("RasterizerVulkan::PrepareDraw")
{
	onenter{
		$this:int = ptrget(argv(0),8);
		$indirect:int = ptrget(argv(1),1);
		$indexed:int = ptrget(argv(2),1);
		$vshash:int = ptrget(argv(3),8);
		$geohash:int = ptrget(argv(4),8);
		$pshash:int = ptrget(argv(5),8);

		if($vshash==0x86d7c683e2589201 && $pshash==0xf9af955d3cbfadeb){
			//printf("RasterizerVulkan::PrepareDraw enter time:%lld this:%lld indirect:%d indexed:%d vshash:%llx gshash:%llx pshash:%llx\n",time(),$this,$indirect,$indexed,$vshash,$geohash,$pshash);
			//dumpstack("RasterizerVulkan::PrepareDraw");
			//assert(0);
		};
	};
};
hook("Vulkan::GraphicsPipeline::UpdateDescriptorSet")
{
	onenter{
		//$log:int = ptrget(argv(0),1);
		//$skip:int = ptrget(argv(1),1);
		$this:int = ptrget(argv(2),8);
		$vshash:int = ptrget(argv(3),8);
		$geohash:int = ptrget(argv(4),8);
		$pshash:int = ptrget(argv(5),8);
		$desctmpl:int = ptrget(argv(6),8);

		if ($vshash==0xfc6acaf325f8139a && $pshash==0xe7751a4a608bfc2d) {
			//printf("Vulkan::GraphicsPipeline::UpdateDescriptorSet vs:%llx gs:%llx ps:%llx desc tmpl:%llx\n",$vshash,$geohash,$pshash,$desctmpl);
			//log
			//ptrset(argv(0),1,1);
			//skip
			//ptrset(argv(1),1,1);
		};
	};
};
hook("UpdateDescriptorQueue::LogAddSampledImage")
{
	onenter{
		//$log:int = ptrget(argv(0),1);
		$this:int = ptrget(argv(1),8);
		$stage:int = ptrget(argv(2),4);
		$binding:int = ptrget(argv(3),4);
		$imgview:int = ptrget(argv(4),8);
		$sampler:int = ptrget(argv(5),8);

		//ptrset(argv(0),1,1);
	};
};
hook("UpdateDescriptorQueue::LogAddImage")
{
	onenter{
		//$log:int = ptrget(argv(0),1);
		$this:int = ptrget(argv(1),8);
		$stage:int = ptrget(argv(2),4);
		$binding:int = ptrget(argv(3),4);
		$imgview:int = ptrget(argv(4),8);

		//ptrset(argv(0),1,1);
	};
};
hook("UpdateDescriptorQueue::LogAddBuffer")
{
	onenter{
		//$log:int = ptrget(argv(0),1);
		$this:int = ptrget(argv(1),8);
		$stage:int = ptrget(argv(2),4);
		$binding:int = ptrget(argv(3),4);
		$buffer:int = ptrget(argv(4),8);
		$offset:int = ptrget(argv(5),8);
		$size:int = ptrget(argv(6),8);

		//ptrset(argv(0),1,1);
	};
};
hook("UpdateDescriptorQueue::LogAddTexelBuffer")
{
	onenter{
		//$log:int = ptrget(argv(0),1);
		$this:int = ptrget(argv(1),8);
		$stage:int = ptrget(argv(2),4);
		$binding:int = ptrget(argv(3),4);
		$texbuffer:int = ptrget(argv(4),8);

		//ptrset(argv(0),1,1);
	};
};
hook("TextureCacheRuntime::CopyImageFailedOnApple")
{
	onenter{
		//$skip:int = ptrget(argv(0),1);
		$src_fmt:int = ptrget(argv(1),4);
		$dst_fmt:int = ptrget(argv(2),4);
		$src_num_samples:int = ptrget(argv(3),4);
		$dst_num_samples:int = ptrget(argv(4),4);
		$src_bytes_per_block:int = ptrget(argv(5),4);
		$dst_bytes_per_block:int = ptrget(argv(6),4);

		printf("TextureCacheRuntime::CopyImageFailedOnApple src_fmt:%d, dst_fmt:%d, src_num_samples:%d, dst_num_samples:%d, src_bytes_per_block:%d, dst_bytes_per_block:%d\n",$src_fmt,$dst_fmt,$src_num_samples,$dst_num_samples,$src_bytes_per_block,$dst_bytes_per_block);
		//assert(0);

		//skip
		//ptrset(argv(0),1,1);
	};
};

hook("ServiceContext::CreateEvent")
{
	onenter{
		$this:int = ptrget(argv(1),8);
		$event:int = ptrget(argv(2),8);
		$id:int = ptrget(argv(3),8);
		$name:string = ptrget(argv(4),8);
		
		printf("ServiceContext::CreateEvent %llx %lld %s", $event, $id, $name);
		//dumpstack("ServiceContext::CreateEvent");
	};
};
hook("ServiceContext::CloseEvent")
{
	onenter{
		$this:int = ptrget(argv(0),8);
		$event:int = ptrget(argv(1),8);
		$id:int = ptrget(argv(2),8);
		
		printf("ServiceContext::CloseEvent %llx %lld", $event, $id);
		//dumpstack("ServiceContext::CloseEvent");
	};
};