
@g_dir_chged : int = 0;
@g_enable_watch_point : int = 0;
@g_enable_mem_log : int = 0;
@g_run_startup : int = 0;
@g_enable_unity_obj_mem_stack_log : int = 0;
@g_enable_gcalloc_log : int = 0;

//======test code begin======
struct(TestStru3)
{
	count : int32;
	ptest2 : TestStru2[12];
};

@ga : int = 123;
@gb : int[3] = [3,5,1];
@gc : int = 456;
@gd : string = "this is a test";

hook(CompileTest)
{
	onenter{
		$a : int = 12;
		$b : int = 13 * 17;
		$d : int = ptrget(addr($a), 4);
		$e : int[4] = [1,$a,3,$b];
		$c : int;
		$e[1] = $d + $e[2] * $c;
		if ($a==12) {
			$c = $a * $b;
		};
		while($c!=0){
			$c = $c - 1;
		};
		loopi($c,0,3,1){
			$d = $d + 1;
		};
		loopd($c,8,0,-2){
			$d = $d + 1;
			break;
		};
		if($a == 12){
			$d = $d + 1;
		}
		else{
			$d = $d - 1;
		};
		$c = addr($e) + argv(0);
		$d = $c < 1 ? 2 : 3;
		$e[0] = $d ?? 1;
		$f : int = struct($d, ptr(ptr(TestStru3.ptest2).ptest).size);
		$g : int = dumpcascadeptr(addr($e), 0x08, 0x08);
		$h1 : int = offset(TestStru3.ptest2[3].size);
		$h2 : int = size(TestStru3);
		ffi(proto(void,noparams,[int,int],[],[]),0x1234,121,121);
		ffi(proto(void,noparams,[int],[float],[]),0x1235,123,123.00);
		return 0;
	};
};

hook(TestMacro1)
{
	onenter{
		$a:int = ptrget(argv(1),4);
		$b:int = ptrget(argv(2),8);
		$c:int = ptrget(argv(3),8);
		printf("TestMacro1 enter time:%lld a:%d b:%f c:%s\n",time(),$a,$b,$c);
		
		SetTimeScale(0.0001);
		printf("TimeScale:%f time:%f",GetTimeScale(), floattime());
		WriteLog("test test test");
		FlushLog();
		
		ptrset(argv(0),4,1);
		return 1;
	};
	onexit{
		printf("TestMacro1 exit time:%lld\n",time());
	};
};
hook(TestMacro2)
{
	onenter{
		$a:int = ptrget(argv(1),4);
		$b:int = ptrget(argv(2),8);
		$c:int = ptrget(argv(3),8);
		printf("TestMacro2 enter time:%lld a:%d b:%f c:%s\n",time(),$a,$b,$c);
		
		return 0;
	};
	onexit{
		printf("TestMacro2 exit time:%lld\n",time());
		ptrset(argv(0),4,2);
	};
};
hook(TestMacro3)
{
	onenter{
		$a:int = ptrget(argv(0),4);
		$b:int = ptrget(argv(1),8);
		$c:int = ptrget(argv(2),8);
		printf("TestMacro3 enter time:%lld a:%d b:%f c:%s\n",time(),$a,$b,$c);
		
		if(platform()==0){
			//test code on windows
			dumpcascadeptr(argv(2),0);
			if($a==123){
				ptrset(argv(0),4,1);
			}
			else{ 
				ptrset(argv(0),4,0);
			};
			$i:int = 0;
			loop($i,0,10){
				printf("+%d\n",$i);
			};
			$j:float = $i;
			while($j>0){
				printf("-%f\n",$j);
				//$j=$j-1;
				dec($j,2.0);
			};
			printf(">>> %f\n", $j);
			printf(">>> %f\n", inc($j));
			printf(">>> %f\n", inc($j, 2.0));
			printf(">>> %f\n", inc($j, 3.0));
			printf("%d %d %d\n", stkix(), hookid(), hookver());
			printf("str contains %d %d\n", stringcontains("test","es","te"), stringnotcontains("test","es","fg"));
			printf("str contains any %d %d\n", stringcontainsany("test","es","te"), stringnotcontainsany("test","es","fg"));
			printf("str find %d %d\n", stringfind("test","es"), stringrfind("test","es"));
			printf("str find2 %d %d\n", stringfind("test","es",1), stringrfind("test","es",0));
			printf("load:%llx\n", LoadLib("kernel32.dll"));
			printf("proc:%llx\n", LoadLibAndGetProc("user32.dll","MessageBoxA"));
			$addr:int = 0x800010004003;
			printf("%llx\n", $addr & (~0x03));
			CheckMemory(28);
		};

		return 1;
	};
	onexit{
		printf("TestMacro3 exit time:%lld\n",time());
	};
};
hook(TestMacro4)
{
	onenter{
		$a:int = ptrget(argv(0),4);
		$b:int = ptrget(argv(1),8);
		$c:int = ptrget(argv(2),8);
		printf("TestMacro4 enter time:%lld a:%d b:%f c:%s\n",time(),$a,$b,$c);
		
		return 0;
	};
	onexit{
		printf("TestMacro4 exit time:%lld\n",time());
	};
};

//======test code end======

hook(DbgScp_Set)
{
	onenter{
		$cmd:int = ptrget(argv(0),4);
		$a:int = ptrget(argv(1),4);
		$b:int = ptrget(argv(2),8);
		$c:int = ptrget(argv(3),8);
		printf("DbgScp_Set enter time:%lld cmd:%d a:%d b:%f c:%s\n",time(),$cmd,$a,$b,$c);
		
		$fields:string[3];
		$seg:int = FindSegment(GetPID(),"libunity.so","r-xp",1,$fields);
		$seg_str:string = format("pid:%d tid:%d unity seg:%llx info:%s %s %s\n",GetPID(),GetTID(),$seg,$fields[0],$fields[1],$fields[2]);
		printf("%s",$seg_str);
		WriteLog($seg_str);
		FlushLog();
		
		if($cmd==1){
			@g_enable_unity_obj_mem_stack_log = 1;
		}
		elif($cmd==2){
			@g_enable_gcalloc_log = 1;
		};
		
		return 1;
	};
	onexit{
		printf("DbgScp_Set exit time:%lld\n",time());
	};
};
hook(DbgScp_Get)
{
	onenter{
		$cmd:int = ptrget(argv(1),4);
		$a:int = ptrget(argv(2),4);
		$b:int = ptrget(argv(3),8);
		$c:int = ptrget(argv(4),8);
		printf("DbgScp_Get enter time:%lld cmd:%d a:%d b:%f c:%s\n",time(),$cmd,$a,$b,$c);

		printf("Model:%s gpu:%s ver:%s\n",GetDeviceModel(),GetGpu(),GetGpuVer());
		/*
		loop($i,1,165){
			CheckMemory($i);
		};
		*/
		return 0;
	};
	onexit{
		printf("DbgScp_Get exit time:%lld\n",time());
		ptrset(argv(0),4,2);
	};
};

hook("DbgScpBreakpoint")
{
	onenter{
		//$ret:int = ptrget(argv(0),1);
		$tag:string = ptrget(argv(1),8);
		$file:string = ptrget(argv(2),8);
		$line:int = ptrget(argv(3),4);
		$func:string = ptrget(argv(4),8);
		//printf("DbgScpBreakpoint enter time:%lld tag:%s file:%s:%d func:%s\n",time(),$tag,$file,$line,$func);
		return 0;
	};
};
hook("DbgScpBreakpointWithIntKey")
{
	onenter{
		//$ret:int = ptrget(argv(0),1);
		$tag:string = ptrget(argv(1),8);
		$key:int = ptrget(argv(2),8);
		$file:string = ptrget(argv(3),8);
		$line:int = ptrget(argv(4),4);
		$func:string = ptrget(argv(5),8);
		//printf("DbgScpBreakpointWithIntKey enter time:%lld tag:%s key:%lld file:%s:%d func:%s\n",time(),$tag,$key,$file,$line,$func);
		return 0;
	};
};
hook("DbgScpBreakpointWithStrKey")
{
	onenter{
		//$ret:int = ptrget(argv(0),1);
		$tag:string = ptrget(argv(1),8);
		$key:string = ptrget(argv(2),8);
		$file:string = ptrget(argv(3),8);
		$line:int = ptrget(argv(4),4);
		$func:string = ptrget(argv(5),8);
		//printf("DbgScpBreakpointWithIntKey enter time:%lld tag:%s key:%s file:%s:%d func:%s\n",time(),$tag,$key,$file,$line,$func);
		return 0;
	};
};
hook("DbgScpBreakpointWithInfo")
{
	onenter{
		//$ret:int = ptrget(argv(0),1);
		$tag:string = ptrget(argv(1),8);
		$info:string = ptrget(argv(2),8);
		$file:string = ptrget(argv(3),8);
		$line:int = ptrget(argv(4),4);
		$func:string = ptrget(argv(5),8);
		//printf("DbgScpBreakpointWithInfo enter time:%lld tag:%s info:%s file:%s:%d func:%s\n",time(),$tag,$info,$file,$line,$func);
		return 0;
	};
};
hook("DbgScpBreakpointWithIntKeyInfo")
{
	onenter{
		//$ret:int = ptrget(argv(0),1);
		$tag:string = ptrget(argv(1),8);
		$key:int = ptrget(argv(2),8);
		$info:string = ptrget(argv(3),8);
		$file:string = ptrget(argv(4),8);
		$line:int = ptrget(argv(5),4);
		$func:string = ptrget(argv(6),8);
		if($tag=="IsForceLighting" && $key==1){
			if (stringcontains($func, "BuildLightmapResources")) {
				//printf("DbgScpBreakpointWithIntKeyInfo enter time:%lld tag:%s key:%lld info:%s file:%s:%d func:%s\n",time(),$tag,$key,$info,$file,$line,$func);
				//dumpstack("IsForceLighting");
				//assert(0);
			};
		}
		elif($tag=="FRenderResourceList::Allocate" && ($key==2566 || $key==2567)){
			//printf("DbgScpBreakpointWithIntKeyInfo enter time:%lld tag:%s key:%lld info:%s file:%s:%d func:%s\n",time(),$tag,$key,$info,$file,$line,$func);
			//assert(0);
		}
		elif($tag=="FRenderResourceList::Deallocate" && ($key==2566 || $key==2567)){
			//printf("DbgScpBreakpointWithIntKeyInfo enter time:%lld tag:%s key:%lld info:%s file:%s:%d func:%s\n",time(),$tag,$key,$info,$file,$line,$func);
			//assert(0);
		}
		elif($tag=="FRenderResource::~FRenderResource" && ($key==2566 || $key==2567)){
			//printf("DbgScpBreakpointWithIntKeyInfo enter time:%lld tag:%s key:%lld info:%s file:%s:%d func:%s\n",time(),$tag,$key,$info,$file,$line,$func);
			//assert(0);
		}
		elif($tag=="FScene::Update"){
			//printf("DbgScpBreakpointWithIntKeyInfo enter time:%lld tag:%s key:%lld info:%s file:%s:%d func:%s\n",time(),$tag,$key,$info,$file,$line,$func);
			//assert(0);
		}
		elif($tag=="TraceSceneUpdate" || $tag=="TraceUpdateSceneInfos"){
			//printf("DbgScpBreakpointWithIntKeyInfo enter time:%lld tag:%s key:%lld info:%s file:%s:%d func:%s\n",time(),$tag,$key,$info,$file,$line,$func);
		};
		return 0;
	};
};
hook("DbgScpBreakpointWithStrKeyInfo")
{
	onenter{
		//$ret:int = ptrget(argv(0),1);
		$tag:string = ptrget(argv(1),8);
		$key:string = ptrget(argv(2),8);
		$info:string = ptrget(argv(3),8);
		$file:string = ptrget(argv(4),8);
		$line:int = ptrget(argv(5),4);
		$func:string = ptrget(argv(6),8);
		if($tag=="FMaterialShaderMap::IsComplete::false"){
			printf("DbgScpBreakpointWithStrKeyInfo enter time:%lld tag:%s key:%s info:%s file:%s:%d func:%s\n",time(),$tag,$key,$info,$file,$line,$func);
			//dumpstack("InteractionShadowPrimitives");
			//assert(0);
		}
		elif($tag=="FMaterialShaderMap::IsComplete::true"){
			printf("DbgScpBreakpointWithStrKeyInfo enter time:%lld tag:%s key:%s info:%s file:%s:%d func:%s\n",time(),$tag,$key,$info,$file,$line,$func);
		};
		return 0;
	};
};
hook("DbgScpAssert")
{
	onenter{
		//$ret:int = ptrget(argv(0),1);
		$tag:string = ptrget(argv(1),8);
		$file:string = ptrget(argv(2),8);
		$line:int = ptrget(argv(3),4);
		$func:string = ptrget(argv(4),8);
		//printf("DbgScpAssert enter time:%lld tag:%s file:%s:%d func:%s\n",time(),$tag,$file,$line,$func);
		if($tag=="UpdateBuildData"){
			//dumpstack("UpdateBuildData");
			//assert(0);
		};
		//assert(0);
		ptrset(argv(0),1,0);
		return 1;
	};
};

hook("Java_com_epicgames_unreal_GameActivity_nativeConsoleCommand")
{
	onenter{
		$cmdStr:string = ptrget(argv(0),8);

		printf("receive android broadcast command: %s\n", $cmdStr);

		//assert(0);
	};
};
hook("USkinnedMeshComponent::ShouldCPUSkin")
{
	onenter{
		//$ret:int = ptrget(argv(0),1);
		$this:int = ptrget(argv(1),8);
		$enabled:int = ptrget(argv(2),1);

		printf("USkinnedMeshComponent::ShouldCPUSkin this:0x%llx enabled:%d\n", $this, $enabled);
		//assert(0);

		ptrset(argv(2),1,1);
		return 0;
	};
};
hook("FScene::Update")
{
	onenter{
		$this:int = ptrget(argv(0),8);
		$skipGpuSkinCache:int = ptrget(argv(1),1);

		//assert(0);
		//ptrset(argv(1),1,1);
		return 0;
	};
};
@g_dynamic_shadow_count = 0;
@g_log_each_dyna_shadow_enabled = 0;
hook("CreateDynamicShadows::SetupInteractionShadows")
{
	onenter{
		$bLogEach:int = ptrget(argv(0),1);
		$bMobile:int = ptrget(argv(1),1);
		$bGMobileInsetShadows:int = ptrget(argv(2),1);
		$bIsMobileCapsuleShadowsEnabled:int = ptrget(argv(3),1);
		$bLightCondition:int = ptrget(argv(4),1);

		inc(@g_dynamic_shadow_count);

		if (@g_log_each_dyna_shadow_enabled){
			ptrset(argv(0),1,1);
		}
		elif (@g_dynamic_shadow_count>100 && @g_dynamic_shadow_count<600){
			ptrset(argv(0),1,1);
			@g_log_each_dyna_shadow_enabled = 1;
		};
		//printf("CreateDynamicShadows::SetupInteractionShadows bMobile:%d bGMobileInsetShadows:%d bIsMobileCapsuleShadowsEnabled:%d bLightCondition:%d count:%d logEnabled:%d\n", $bMobile, $bGMobileInsetShadows, $bIsMobileCapsuleShadowsEnabled, $bLightCondition, @g_dynamic_shadow_count, @g_log_each_dyna_shadow_enabled);
	};
};
hook("CreateDynamicShadows::SetupInteractionShadows::InteractionShadowPrimitives")
{
	onenter{
		$NumPrims:int = ptrget(argv(0),4);

		//printf("CreateDynamicShadows::SetupInteractionShadows::InteractionShadowPrimitives NumPrims:%d\n",$NumPrims);
	};
};
hook("CreateDynamicShadows::SetupInteractionShadows::InteractionShadowPrimitives::foreach")
{
	onenter{
		$Idx:int = ptrget(argv(0),4);
		$NumPrims:int = ptrget(argv(1),4);
		$LightId:int = ptrget(argv(2),4);
		$PersistentIndex:int = ptrget(argv(3),4);
		$cstrOwnerName:string = ptrget(argv(4),8);
		$cstrResName:string = ptrget(argv(5),8);
		$cstrMatName:string = ptrget(argv(6),8);
		$cstrBaseMatName:string = ptrget(argv(7),8);
		$StaticMeshNum:int = ptrget(argv(8),4);
		$bHasShadow:int = ptrget(argv(9),1);
		$X:float = ptrget(argv(10),8);
		$Y:float = ptrget(argv(11),8);
		$Z:float = ptrget(argv(12),8);

		if (stringcontainsany($cstrOwnerName,"WhiteWolf","GoldBlack")) {
			//printf("CreateDynamicShadows::SetupInteractionShadows::InteractionShadowPrimitives::foreach Idx:%d NumPrims:%d LightId:%d PersistentIndex:%d OwnerName:%s ResName:%s Mat:%s(%s) MeshNum:%d HasShadow:%d Pos:(%f,%f,%f)\n", $Idx, $NumPrims, $LightId, $PersistentIndex, $cstrOwnerName, $cstrResName, $cstrMatName, $cstrBaseMatName, $StaticMeshNum, $bHasShadow, $X, $Y, $Z);
		};
	};
};
hook("CreateDynamicShadows::SetupInteractionShadows::MovingPrimitiveList")
{
	onenter{
		$NumMovingPrims:int = ptrget(argv(0),4);

		//printf("CreateDynamicShadows::SetupInteractionShadows::MovingPrimitiveList NumPrims:%d\n",$NumMovingPrims);
	};
};
hook("CreateDynamicShadows::SetupInteractionShadows::MovingPrimitiveList::foreach")
{
	onenter{
		$NumMovingPrims:int = ptrget(argv(0),4);
		$LightId:int = ptrget(argv(1),4);
		$PersistentIndex:int = ptrget(argv(2),4);
		$cstrOwnerName:string = ptrget(argv(3),8);
		$cstrResName:string = ptrget(argv(4),8);
		$cstrMatName:string = ptrget(argv(5),8);
		$cstrBaseMatName:string = ptrget(argv(6),8);
		$StaticMeshNum:int = ptrget(argv(7),4);
		$bHasShadow:int = ptrget(argv(8),1);
		$X:float = ptrget(argv(9),8);
		$Y:float = ptrget(argv(10),8);
		$Z:float = ptrget(argv(11),8);

		if (stringcontainsany($cstrOwnerName,"WhiteWolf","GoldBlack")) {
			//printf("CreateDynamicShadows::SetupInteractionShadows::MovingPrimitiveList::foreach NumPrims:%d LightId:%d PersistentIndex:%d OwnerName:%s ResName:%s Mat:%s(%s) MeshNum:%d HasShadow:%d Pos:(%f,%f,%f)\n", $NumMovingPrims, $LightId, $PersistentIndex, $cstrOwnerName, $cstrResName, $cstrMatName, $cstrBaseMatName, $StaticMeshNum, $bHasShadow, $X, $Y, $Z);
		};
	};
};
hook("CreateDynamicShadows::SetupInteractionShadows::StaticPrimitiveList")
{
	onenter{
		$NumStaticPrims:int = ptrget(argv(0),4);

		//printf("CreateDynamicShadows::SetupInteractionShadows::StaticPrimitiveList NumPrims:%d\n",$NumStaticPrims);
	};
};
hook("CreateDynamicShadows::SetupInteractionShadows::StaticPrimitiveList::foreach")
{
	onenter{
		$NumStaticPrims:int = ptrget(argv(0),4);
		$LightId:int = ptrget(argv(1),4);
		$PersistentIndex:int = ptrget(argv(2),4);
		$cstrOwnerName:string = ptrget(argv(3),8);
		$cstrResName:string = ptrget(argv(4),8);
		$cstrMatName:string = ptrget(argv(5),8);
		$cstrBaseMatName:string = ptrget(argv(6),8);
		$StaticMeshNum:int = ptrget(argv(7),4);
		$bHasShadow:int = ptrget(argv(8),1);
		$X:float = ptrget(argv(9),8);
		$Y:float = ptrget(argv(10),8);
		$Z:float = ptrget(argv(11),8);

		if (stringcontainsany($cstrOwnerName,"WhiteWolf","GoldBlack")) {
			//printf("CreateDynamicShadows::SetupInteractionShadows::StaticPrimitiveList::foreach NumPrims:%d LightId:%d PersistentIndex:%d OwnerName:%s ResName:%s Mat:%s(%s) MeshNum:%d HasShadow:%d Pos:(%f,%f,%f)\n", $NumStaticPrims, $LightId, $PersistentIndex, $cstrOwnerName, $cstrResName, $cstrMatName, $cstrBaseMatName, $StaticMeshNum, $bHasShadow, $X, $Y, $Z);
		};
	};
};
hook("FSceneRenderer::SetupInteractionShadows::check")
{
	onenter{
		$cstrOwnerName:string = ptrget(argv(0),8);
		$cstrResName:string = ptrget(argv(1),8);
		$X:float = ptrget(argv(2),8);
		$Y:float = ptrget(argv(3),8);
		$Z:float = ptrget(argv(4),8);
		$bCreateTranslucentObjectShadow:int = ptrget(argv(5),1);
		$bCreateInsetObjectShadow:int = ptrget(argv(6),1);
		$bCreateObjectShadowForStationaryLight:int = ptrget(argv(7),1);

		if (stringcontainsany($cstrOwnerName,"WhiteWolf","GoldBlack")) {
			//printf("FSceneRenderer::SetupInteractionShadows::check OwnerName:%s ResName:%s Pos:(%f,%f,%f) flags:(%d %d %d)\n", $cstrOwnerName, $cstrResName, $X, $Y, $Z, $bCreateTranslucentObjectShadow, $bCreateInsetObjectShadow, $bCreateObjectShadowForStationaryLight);
			//force continue
			//ptrset(argv(5), 1, 1);
		};
	};
};
hook("FSceneRenderer::CreatePerObjectProjectedShadow::skip")
{
	onenter{
		//$forceContinue:int = ptrget(argv(0),1);
		$cstrOwnerName:string = ptrget(argv(1),8);
		$cstrResName:string = ptrget(argv(2),8);
		$X:float = ptrget(argv(3),8);
		$Y:float = ptrget(argv(4),8);
		$Z:float = ptrget(argv(5),8);
		$bOpaque:int = ptrget(argv(6),1);
		$bTranslucentRelevance:int = ptrget(argv(7),1);

		if (stringcontainsany($cstrOwnerName,"WhiteWolf","GoldBlack")) {
			//printf("FSceneRenderer::CreatePerObjectProjectedShadow::skip OwnerName:%s ResName:%s Pos:(%f,%f,%f) bOpaque:%d bTranslucentRelevance:%d\n", $cstrOwnerName, $cstrResName, $X, $Y, $Z, $bOpaque, $bTranslucentRelevance);
		};
	};
};
@g_compute_relevance_count = 0;
@g_log_each_mesh_enabled = 0;
hook("FRelevancePacket::ComputeRelevance")
{
	onenter{
		$bLogEach:int = ptrget(argv(0),1);
		$NumPrims:int = ptrget(argv(1),4);

		if ($NumPrims > 0) {
			inc(@g_compute_relevance_count);

			if (@g_log_each_mesh_enabled){
				//ptrset(argv(0),1,0);
			}
			elif (@g_compute_relevance_count>500 && @g_compute_relevance_count<600){
				//ptrset(argv(0),1,1);
				@g_log_each_mesh_enabled = 1;
			};
		};
		//printf("FRelevancePacket::ComputeRelevance tid:%lld NumPrims:%d frame_count:%d log_enabled:%d\n", GetTID(), $NumPrims, @g_compute_relevance_count, @g_log_each_mesh_enabled);
	};
};
hook("FRelevancePacket::ComputeRelevance::foreach::Mesh")
{
	onenter{
		$InputPrimsIndex:int = ptrget(argv(0),4);
		$MeshIndex:int = ptrget(argv(1),4);
		$NumStaticMeshes:int = ptrget(argv(2),4);
		$TotalMeshes:int = ptrget(argv(3),4);
		$cstrOwnerName:string = ptrget(argv(4),8);
		$cstrResName:string = ptrget(argv(5),8);
		$cstrMatName:string = ptrget(argv(6),8);
		$cstrBaseMatName:string = ptrget(argv(7),8);
		$DrawCount:int = ptrget(argv(8),1);
		$DrawCommandsAddr:int = argv(9);
		$AlwaysDrawCount:int = ptrget(argv(10),1);
		$AlwaysDrawCommandsAddr:int = argv(11);
		$MarkMask:int = ptrget(argv(12),1);
		$X:float = ptrget(argv(13),8);
		$Y:float = ptrget(argv(14),8);
		$Z:float = ptrget(argv(15),8);

		$DrawCommands:int[8] = [-1,-1,-1,-1,-1,-1,-1,-1];
		if ($DrawCount > 0) {
			$ix:int;
			loop($ix,0,$DrawCount-1){
				if ($ix>=8) {
					break;
				};
				$DrawCommands[$ix] = ptrget($DrawCommandsAddr+$ix,1);
			};
		};
		$AlwaysDrawCommands:int[8] = [-1,-1,-1,-1,-1,-1,-1,-1];
		if ($AlwaysDrawCount > 0) {
			$ix:int;
			loop($ix,0,$AlwaysDrawCount-1){
				if ($ix>=8) {
					break;
				};
				$AlwaysDrawCommands[$ix] = ptrget($AlwaysDrawCommandsAddr+$ix,1);
			};
		};

		/*
		printf("FRelevancePacket::ComputeRelevance::foreach::Mesh PrimIndex:%d MeshIndex:%d NumStaticMeshes:%d TotalMeshes:%d OwnerName:%s ResName:%s Mat:%s(%s) DrawCount:%d [%d,%d,%d,%d,%d,%d,%d,%d] AlwaysDrawCount:%d [%d,%d,%d,%d,%d,%d,%d,%d] MarkMask:%d Pos:(%f,%f,%f)\n", $InputPrimsIndex, $MeshIndex, $NumStaticMeshes, $TotalMeshes, $cstrOwnerName, $cstrResName, $cstrMatName, $cstrBaseMatName
			, $DrawCount, $DrawCommands[0], $DrawCommands[1], $DrawCommands[2], $DrawCommands[3], $DrawCommands[4], $DrawCommands[5], $DrawCommands[6], $DrawCommands[7]
			, $AlwaysDrawCount, $AlwaysDrawCommands[0], $AlwaysDrawCommands[1], $AlwaysDrawCommands[2], $AlwaysDrawCommands[3], $AlwaysDrawCommands[4], $AlwaysDrawCommands[5], $AlwaysDrawCommands[6], $AlwaysDrawCommands[7]
			, $MarkMask, $X, $Y, $Z);
		*/
	};
};
@g_begin_init_views_count = 0;
@g_begin_init_views_log_detail_enabled = 0;
hook("FDeferredShadingSceneRenderer::BeginInitViews")
{
	onenter{
		$bLogDetail:int = ptrget(argv(0),1);

		inc(@g_begin_init_views_count);

		if (@g_begin_init_views_log_detail_enabled){
			ptrset(argv(0),1,1);
		}
		elif (@g_begin_init_views_count>100 && @g_begin_init_views_count<600){
			ptrset(argv(0),1,1);
			@g_begin_init_views_log_detail_enabled = 1;
		};

		//printf("FDeferredShadingSceneRenderer::BeginInitViews tid:%lld frame_count:%d log_enabled:%d\n", GetTID(), @g_begin_init_views_count, @g_begin_init_views_log_detail_enabled);
	};
};
hook("FDeferredShadingSceneRenderer::BeginInitViews::ShadowGrid_ShouldCastShadow")
{
	onenter{
		$SizeX:float = ptrget(argv(0),8);
		$SizeY:float = ptrget(argv(1),8);
		$CountX:int = ptrget(argv(2),4);
		$CountY:int = ptrget(argv(3),4);
		$OriginX:float = ptrget(argv(4),8);
		$OriginY:float = ptrget(argv(5),8);
		$NumBits:int = ptrget(argv(6),4);
		$MaxBits:int = ptrget(argv(7),4);
		$BitData:int = ptrget(argv(8),8);
		$cstrOwnerName:string = ptrget(argv(9),8);
		$cstrResName:string = ptrget(argv(10),8);
		$bCastShadow:int = ptrget(argv(11),1);
		$PX:float = ptrget(argv(12),8);
		$PY:float = ptrget(argv(13),8);

		if (stringcontainsany($cstrOwnerName,"WhiteWolf","GoldBlack")) {
			//printf("FDeferredShadingSceneRenderer::BeginInitViews::ShadowGrid_ShouldCastShadow tid:%lld size:(%f,%f) count:(%d,%d) origin:(%f,%f) num:(%d %d) data:0x%llx OwnerName:%s ResName:%s cast_shadow:%d pos:(%f,%f)\n", GetTID(), $SizeX, $SizeY, $CountX, $CountY, $OriginX, $OriginY, $NumBits, $MaxBits, $BitData, $cstrOwnerName, $cstrResName, $bCastShadow, $PX, $PY);
		};
	};
};
@g_init_views_count = 0;
@g_init_views_log_detail_enabled = 0;
hook("FMobileSceneRenderer::InitViews")
{
	onenter{
		$bLogDetail:int = ptrget(argv(0),1);

		inc(@g_init_views_count);

		if (@g_init_views_log_detail_enabled){
			ptrset(argv(0),1,1);
		}
		elif (@g_init_views_count>100 && @g_init_views_count<600){
			ptrset(argv(0),1,1);
			@g_init_views_log_detail_enabled = 1;
		};

		//printf("FMobileSceneRenderer::InitViews tid:%lld frame_count:%d log_enabled:%d\n", GetTID(), @g_init_views_count, @g_init_views_log_detail_enabled);
	};
};
hook("FMobileSceneRenderer::InitViews::ShadowGrid_ShouldCastShadow")
{
	onenter{
		$SizeX:float = ptrget(argv(0),8);
		$SizeY:float = ptrget(argv(1),8);
		$CountX:int = ptrget(argv(2),4);
		$CountY:int = ptrget(argv(3),4);
		$OriginX:float = ptrget(argv(4),8);
		$OriginY:float = ptrget(argv(5),8);
		$NumBits:int = ptrget(argv(6),4);
		$MaxBits:int = ptrget(argv(7),4);
		$BitData:int = ptrget(argv(8),8);
		$cstrOwnerName:string = ptrget(argv(9),8);
		$cstrResName:string = ptrget(argv(10),8);
		$bCastShadow:int = ptrget(argv(11),1);
		$PX:float = ptrget(argv(12),8);
		$PY:float = ptrget(argv(13),8);

		if (stringcontainsany($cstrOwnerName,"WhiteWolf","GoldBlack")) {
			//printf("FMobileSceneRenderer::InitViews::ShadowGrid_ShouldCastShadow tid:%lld size:(%f,%f) count:(%d,%d) origin:(%f,%f) num:(%d %d) data:0x%llx OwnerName:%s ResName:%s cast_shadow:%d pos:(%f,%f)\n", GetTID(), $SizeX, $SizeY, $CountX, $CountY, $OriginX, $OriginY, $NumBits, $MaxBits, $BitData, $cstrOwnerName, $cstrResName, $bCastShadow, $PX, $PY);
		};
	};
};
hook("FilterPrimitiveForShadows::skip_switch")
{
	onenter{
		//$bLogDbgScp:int = ptrget(argv(0),1);
		ptrset(argv(0),1,1);
	};
};
hook("FilterPrimitiveForShadows::skip")
{
	onenter{
		//$forceContinue:int = ptrget(argv(0),1);
		$cstrOwnerName:string = ptrget(argv(1),8);
		$cstrResName:string = ptrget(argv(2),8);
		$X:float = ptrget(argv(3),8);
		$Y:float = ptrget(argv(4),8);
		$Z:float = ptrget(argv(5),8);

		if (stringcontainsany($cstrOwnerName,"WhiteWolf","GoldBlack")) {
			//printf("FilterPrimitiveForShadows::skip OwnerName:%s ResName:%s Pos:(%f,%f,%f), but force continue\n", $cstrOwnerName, $cstrResName, $X, $Y, $Z);
			//ptrset(argv(0),1,1);
		};
	};
};
hook("FMaterialShaderMap::IsComplete")
{
	onenter{
		//$ret:int = ptrget(argv(0),1);
		//$bLogFalse:int = ptrget(argv(1),1);
		//$bLogTrue:int = ptrget(argv(2),1);
		$bSilent:int = ptrget(argv(3),1);
		$bComplete:int = ptrget(argv(4),1);
		$cstrAssetName:string = ptrget(argv(5),8);

		printf("FMaterialShaderMap::IsComplete bSilent:%d bComplete:%d AssetName:%s\n", $bSilent, $bComplete, $cstrAssetName);
		//bLogFalse
		ptrset(argv(1),1,1);
		//bLogTrue
		ptrset(argv(2),1,1);
		//bSilent
		ptrset(argv(3),1,0);
	};
};